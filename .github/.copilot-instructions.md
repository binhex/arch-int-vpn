# Bash Coding Standards for GitHub Copilot

## Variable Naming and Scoping Rules

### Local Variables
- All local variables within functions MUST be lowercase
- ALL lowercase variables within functions MUST be explicitly declared with `local` keyword
- This includes variables that store command output, temporary values, or any lowercase variable assignment
- Local variables should use snake_case naming convention
- Even variables assigned from command substitution must be declared as `local`

```bash
function example_function() {
  local my_variable="value"
  local another_var="${1}"
  local -a my_array=()
  local command_output
  local temp_file="/tmp/example.tmp"

  # Command output must also be local
  command_output=$(grep "pattern" file.txt)

  # Any lowercase variable assignment must be local
  local exit_code=$?
}
```

### Global Variables
- All global variables MUST be UPPERCASE
- Global variables should use SCREAMING_SNAKE_CASE
- Environment variables are typically global and uppercase

```bash
# Global variables
VPN_REMOTE_SERVER="example.com"
DEBUG="true"
APPLICATION="qbittorrent"
```

## Variable Usage Rules

### Quoting and Braces
- All variable references MUST use double quotes and curly braces
- This prevents word splitting and ensures proper variable expansion

```bash
# Correct
echo "Server is ${VPN_REMOTE_SERVER}"
local config_file="${CONFIG_DIR}/app.conf"
if [[ "${DEBUG}" == "true" ]]; then

# Incorrect
echo "Server is $VPN_REMOTE_SERVER"
local config_file=$CONFIG_DIR/app.conf
if [[ $DEBUG == "true" ]]; then
```

## Formatting Rules

### Indentation
- Use 2 spaces for indentation, NOT tabs
- Be consistent throughout all files

```bash
function example() {
  local var="value"
  if [[ "${var}" == "value" ]]; then
    echo "Match found"
  fi
}
```

## Function Guidelines

### Code Organization
- Create functions where possible instead of writing bare code at the global scope
- Group related functionality into well-named functions
- Use a main function or clear entry point for script execution
- This improves readability, maintainability, and testability
- Avoid global executable code except for simple variable assignments and the main function call

```bash
# Good - organized into functions
function setup_environment() {
  local config_dir="${1}"
  shift
  # setup logic here
}

function main() {
  setup_environment "${CONFIG_DIR}"
  # main logic here
}

main "$@"

# Avoid - bare code at global scope
if [[ "${DEBUG}" == "true" ]]; then
  echo "Debug mode"
fi
# ... more bare code
```

### Parameter Handling
- Use meaningful parameter names as local variables
- Pass variables between functions as arguments, not globals (for lowercase vars)
- Use `shift` to handle function arguments instead of positional parameters like `"${1}"`, `"${2}"`, etc.

```bash
function process_data() {
  local input_file="${1}"
  local output_dir="${2}"
  shift 2
  local temp_file="${output_dir}/temp.txt"

  # Process the file
  process_file "${input_file}" "${temp_file}"
}

# Preferred approach using shift
function process_data_preferred() {
  local input_file="${1}"
  shift
  local output_dir="${1}"
  shift
  local temp_file="${output_dir}/temp.txt"

  # Process the file
  process_file "${input_file}" "${temp_file}"
}
```

### Array Handling
- Use nameref for passing arrays by reference
- Declare arrays as local when possible

```bash
function setup_arrays() {
  local -n array_ref=$1
  local -a local_array=()

  array_ref=("${local_array[@]}")
}
```

## Examples of Proper Style

```bash
#!/bin/bash

# Global configuration
CONFIG_FILE="/etc/app/config.conf"
DEBUG="false"

function read_config() {
  local config_path="${1}"
  local config_value

  if [[ -f "${config_path}" ]]; then
    config_value=$(grep "setting" "${config_path}")
    echo "${config_value}"
  fi
}

function main() {
  local app_config
  local -a port_array=()

  app_config=$(read_config "${CONFIG_FILE}")

  if [[ "${DEBUG}" == "true" ]]; then
    echo "Config: ${app_config}"
  fi
}

main "$@"
```

## Key Principles
1. **Scope Clarity**: Local vars lowercase, global vars UPPERCASE
2. **Safety**: Always quote variables with curly braces
3. **Consistency**: 2-space indentation throughout
4. **Maintainability**: Pass data via arguments, not global variables
5. **Readability**: Clear variable names and consistent formatting

When generating bash code, always follow these standards for clean, maintainable, and safe shell scripts.