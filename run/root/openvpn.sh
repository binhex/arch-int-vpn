#!/bin/bash

function create_openvpn_cli() {
  # define common command line parameters for openvpn
  local openvpn_cli="/usr/bin/openvpn --reneg-sec 0 --mute-replay-warnings --auth-nocache --setenv VPN_PROV '${VPN_PROV}' --setenv VPN_CLIENT '${VPN_CLIENT}' --setenv DEBUG '${DEBUG}' --setenv VPN_DEVICE_TYPE '${VPN_DEVICE_TYPE}' --setenv VPN_ENABLED '${VPN_ENABLED}' --setenv VPN_REMOTE_SERVER '${VPN_REMOTE_SERVER}' --setenv APPLICATION '${APPLICATION}' --script-security 2 --writepid /root/openvpn.pid --remap-usr1 SIGHUP --log-append /dev/stdout --pull-filter ignore 'up' --pull-filter ignore 'down' --pull-filter ignore 'route-ipv6' --pull-filter ignore 'ifconfig-ipv6' --pull-filter ignore 'tun-ipv6' --pull-filter ignore 'dhcp-option DNS6' --pull-filter ignore 'persist-tun' --pull-filter ignore 'reneg-sec' --up /root/openvpnup.sh --up-delay --up-restart"

  if [[ -z "${VPN_PING}" ]]; then
    # if no ping options in the ovpn file then specify keepalive option
    openvpn_cli="${openvpn_cli} --keepalive 10 60"
  fi

  if [[ "${VPN_PROV}" == "pia" || "${VPN_PROV}" == "protonvpn" ]]; then
    # add pia specific flags
    openvpn_cli="${openvpn_cli} --setenv STRICT_PORT_FORWARD '${STRICT_PORT_FORWARD}' --setenv VPN_USER '${VPN_USER}' --setenv VPN_PASS '${VPN_PASS}' --down /root/openvpndown.sh --disable-occ"
  fi

  if [[ -n "${VPN_USER}" && -n "${VPN_PASS}" ]]; then
    # add additional flags to pass credentials
    openvpn_cli="${openvpn_cli} --auth-user-pass credentials.conf"
  fi

  if [[ -n "${VPN_OPTIONS}" ]]; then
    # add additional flags to openvpn cli
    # note do not single/double quote the variable VPN_OPTIONS
    openvpn_cli="${openvpn_cli} ${VPN_OPTIONS}"
  fi

  # finally add options specified in ovpn file
  openvpn_cli="${openvpn_cli} --cd /config/openvpn --config '${VPN_CONFIG}'"

  # Export for use in other functions
  export OPENVPN_CLI="${openvpn_cli}"
}

function add_remote_server_ip() {
  # check answer is not blank, generated in start.sh, if it is blank assume bad ns or vpn remote is an ip address
  if [[ -n "${VPN_REMOTE_IP}" ]]; then
    # iterate through list of ip addresses and add each ip as a --remote option to ${OPENVPN_CLI}
    local vpn_remote_ip_item
    for vpn_remote_ip_item in "${VPN_REMOTE_IP_ARRAY[@]}"; do
      OPENVPN_CLI="${OPENVPN_CLI} --remote ${vpn_remote_ip_item} ${VPN_REMOTE_PORT} ${VPN_REMOTE_PROTOCOL}"
    done

    # randomize the --remote option that openvpn will use to connect. this should help
    # prevent getting stuck on a particular server should it become unstable/unavailable
    OPENVPN_CLI="${OPENVPN_CLI} --remote-random"
  fi
}

function run_openvpn() {
  create_openvpn_cli
  add_remote_server_ip

  if [[ "${DEBUG}" == "true" ]]; then
    echo "[debug] OpenVPN command line:- ${OPENVPN_CLI}"
  fi

  echo "[info] Starting OpenVPN (non daemonised)..."
  eval "${OPENVPN_CLI}"
}

function watchdog() {
  # loop and watch out for files generated by user nobody scripts that indicate failure
  while true; do
    # reset flag, used to indicate connection status
    local down="false"

    # if '/tmp/portclosed' file exists (generated by /home/nobody/watchdog.sh when incoming port
    # detected as closed) then terminate openvpn
    if [[ -f "/tmp/portclosed" ]]; then
      echo "[info] Sending SIGTERM (-15) to 'openvpn' due to port closed..."
      down="true"
      rm -f "/tmp/portclosed"
    fi

    # if '/tmp/dnsfailure' file exists (generated by tools.sh when dns fails)
    # then terminate openvpn
    if [[ -f "/tmp/dnsfailure" ]]; then
      echo "[info] Sending SIGTERM (-15) to 'openvpn' due to dns failure..."
      down="true"
      rm -f "/tmp/dnsfailure"
    fi

    # if '/tmp/portfailure' file exists (generated by tools.sh when incoming port
    # allocation fails) then terminate openvpn
    if [[ -f "/tmp/portfailure" ]]; then
      echo "[info] Sending SIGTERM (-15) to 'openvpn' due to incoming port allocation failure..."
      down="true"
      rm -f "/tmp/portfailure"
    fi

    if [[ "${down}" == "true" ]]; then
      if [[ -f '/tmp/endpoints' ]]; then
        # read in associative array of endpoint names and ip addresses from file created from function resolve_vpn_endpoints in tools.sh
        source '/tmp/endpoints'

        local endpoint_name
        local endpoint_ip_array
        for endpoint_name in "${!VPN_REMOTE_ARRAY[@]}"; do
          endpoint_ip_array=( "${VPN_REMOTE_ARRAY[$endpoint_name]}" )
          # run function to round robin the endpoint ip and write to /etc/hosts
          round_robin_endpoint_ip "${endpoint_name}" "${endpoint_ip_array[@]}"
        done
      fi
    fi

    # if flagged by above scripts then down vpn tunnel
    if [[ "${down}" == "true" ]]; then
      pkill -SIGTERM "openvpn"
    fi

    sleep 30s
  done
}

function start_openvpn() {
  # split comma separated string into array from VPN_REMOTE_SERVER env var
  local -a vpn_remote_server_list
  IFS=',' read -ra vpn_remote_server_list <<< "${VPN_REMOTE_SERVER}"

  # split comma separated string into array from VPN_REMOTE_PORT env var
  local -a vpn_remote_port_list
  IFS=',' read -ra vpn_remote_port_list <<< "${VPN_REMOTE_PORT}"

  # split comma separated string into array from VPN_REMOTE_PROTOCOL env var
  local -a vpn_remote_protocol_list
  IFS=',' read -ra vpn_remote_protocol_list <<< "${VPN_REMOTE_PROTOCOL}"

  # convert list of ip's back into an array (cannot export arrays in bash)
  IFS=' ' read -ra VPN_REMOTE_IP_ARRAY <<< "${VPN_REMOTE_IP_LIST}"

  # setup ip tables and routing for application
  source /root/iptable.sh

  # start background watchdog function
  watchdog &

  # loop back around to top if run out of vpn remote servers
  while true; do
    # iterate over arrays and send to start_openvpn_cli function (blocking until openvpn process dies)
    local index
    for index in "${!vpn_remote_port_list[@]}"; do
      # required as this is passed via openvpn setenv to tools.sh script
      # (checks endpoint is in list of port forward enabled endpoints)
      VPN_REMOTE_SERVER="${vpn_remote_server_list[$index]}"
      VPN_REMOTE_PORT="${vpn_remote_port_list[$index]}"
      VPN_REMOTE_PROTOCOL="${vpn_remote_protocol_list[$index]}"
      VPN_REMOTE_IP="${VPN_REMOTE_IP_ARRAY[$index]}"

      if [[ "${DEBUG}" == "true" ]]; then
        echo "[debug] VPN remote configuration options as follows..."
        echo "[debug] VPN remote server is defined as '${VPN_REMOTE_SERVER}'"
        echo "[debug] VPN remote port is defined as '${VPN_REMOTE_PORT}'"
        echo "[debug] VPN remote protocol is defined as '${VPN_REMOTE_PROTOCOL}'"
        echo "[debug] VPN remote ip is defined as '${VPN_REMOTE_IP}'"
      fi

      run_openvpn
    done
  done
}

function main() {
  # source in resolve dns and round robin ip's from functions
  source tools.sh

  # start openvpn function
  start_openvpn
}

main "$@"